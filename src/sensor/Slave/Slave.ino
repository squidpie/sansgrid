/* SPI Slave Test Code
 * Designed to run on the Arduino UNO
 */
 
#include <SPI.h>
#define NUM_BYTES 98
#define SLAVE_READY 7
#define DELAY 6

// Buffers
uint8_t rx_buf [NUM_BYTES];
// FLY TEST PACKET
uint8_t tx_buf [NUM_BYTES] = { 0xAD,// Control Byte 1 BYTE
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xA8,
        0x00,0x01, // IP Address 16 BYTES
        0xF0, // Payload (Data Type) 1 BYTE
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	
        0x00,0x00,0x53,0x61,0x6E,0x73,0x67,0x72,0x69,0x64 }; // Payload 
        // Network ID 80 BYTES
        // Payload 81 BYTES

// Buffer position markers
volatile uint8_t pos;
volatile uint8_t pos_b;

// SPI command byte
volatile uint8_t command;

// Process flag
volatile boolean process_it;

// Setup SPI Slave device
void setup (void)
{
  Serial.begin (9600);   // debugging

  // Transmit on MISO - Master In Slave Out
  pinMode(MISO, OUTPUT);
  
  // Initialize Slave Ready port
  pinMode(SLAVE_READY, OUTPUT);
  digitalWrite(SLAVE_READY, HIGH);
  
  // Initiate SPI in slave mode
  SPCR |= _BV(SPE);
  
  // Set buffer Positions 
  pos = 0;               // rxfer empty
  pos_b = 0;             // txfer first uint8_t
  
  // Set Command byte to default
  command = 0;           // Set command to default
  
  // Set Process flag to default 
  process_it = false;    // Set flag to default

  // Turn on SPI interrupt
  SPI.attachInterrupt();

}  // End of Setup

// SPI Interrupt Service Routine
ISR (SPI_STC_vect)
{
  // Read byte from SPI SPDR register
  uint8_t c = SPDR;
  // Call Command Byte
  switch(command){
  case 0x00:
      // Set Command byte from intial dummy byte
      command = c;
      break;
  case 0xAD:
      // Receive SPI Packet from Master
      if ( pos < NUM_BYTES ){
          rx_buf [pos++] = c;
          // If buffer is full set process_it flag
          if ( pos == NUM_BYTES - 1 )
              process_it = true;
      }
      break;
  case 0xFD:
      // Transmit SPI Packet to Master
      SPDR = tx_buf[ pos_b++ ];
      // If buffer is full set process_it flag
      if ( pos_b == NUM_BYTES )               
          process_it = true; 
      break;
  default:
      break;
    }  // End of Command Byte
}  // End of Interupt Service Routine

// Main Loop - Wait for flag set in ISR
void loop (void){
  // Check if process packet flag is set
  if (process_it)
    { 
    Serial.println( "Packet" );  
    for( int i = 0 ; i < NUM_BYTES ; i++ )
        Serial.println ( rx_buf[i], DEC ); 
    pos = 0;
    pos_b = 0;
    command = 0;
    process_it = false;
    }  // end of flag set
    
    /*delay(6000);
    digitalWrite( SLAVE_READY , LOW );
    delayMicroseconds( 5 );
    digitalWrite( SLAVE_READY , HIGH );
    delay(6000);*/
}  // end of loop

// Peck
/*byte tx [ NUM_BYTES ] = { 0xAD,// Control Byte 1 BYTE
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xA8,
        0x00,0x01, // IP Address 16 BYTES
        0x01, // Payload (Data Type) 1 BYTE
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xA8,
        0x00,0x01,// Router IP 16 BYTES
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xA8,
        0x00,0x0A, // Assigned IP 16 BYTES
        0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
        0x01,0x01, // Server ID 16 BYTES
        0x01, // Recognition 1 BYTE
        0x00,0x00,0x00,0x00, // Manid 4 BYTES
        0x00,0x00,0x00,0x00, // Modnum 4 BYTES
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // SN 8 BYTES
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00 }; // Unused 15 BYTES
        // Payload 81 BYTES
// Sing
byte tx [ NUM_BYTES ] = { 0xAD,// Control Byte 1 BYTE
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xA8,
        0x00,0x01, // IP Address 16 BYTES
        0x02, // Payload (Data Type) 1 BYTE
	0x09,0xC4,0x59,0xDC,0xA6,0xF5,0xF0,0x16,0x54,0xE5,0xC0,0x87,0xB0,0x94,
        0xBA,0x89,0x16,0xFF,0x0C,0x26,0xEF,0xE9,0xAF,0x53,0x02,0x83,0x7D,0x1B,
        0xF9,0x6A,0x94,0x61,0x57,0x27,0xDF,0xDE,0xB7,0x0B,0x2D,0xA4,0xC6,0x23,
        0x8D,0x66,0x15,0x38,0x4A,0x28,0xE3,0x3F,0x29,0xB1,0x2F,0xBD,0xB4,0xED,
        0x28,0xF1,0x3D,0xED,0x25,0xB3,0xC1,0xE2, // Payload Server Public Key 
        // 64 BYTES
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00 }; // Unused 16 BYTES
        // Payload 81 Bytes
// Nest
byte tx [ NUM_BYTES ] = { 0xAD,// Control Byte 1 BYTE
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xA8,
        0x00,0x01, // IP Address 16 BYTES
        0x10, // Payload (Data Type) 1 BYTE
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0 }; // Payload Unused
        // 80 BYTES
        // Payload 81 BYTES
*/
